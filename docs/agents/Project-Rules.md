1. Общая идея процесса

Ты хочешь, чтобы процесс был похож на человеческую команду:

Ты даёшь свободный текст: идея / фича / проблема (по-русски, не код).

Агент-Product/Analyst → формализует требования.

Агент-Architect → проектирует/обновляет архитектуру и точки интеграции с уже существующим кодом.

Агент-Planner → разбивает на задачи и определяет порядок (что трогать в коде, что НЕ трогать).

Агент-Implementer → пишет/меняет код, максимально аккуратно.

Агент-Tester → добавляет/обновляет тесты, проверки.

Агент-Reviewer/Guardian → проверяет на дубли, конфликт, несоответствие архитектуре и требованиям.

Все агенты работают поверх общей базы знаний проекта:
1–2 markdown-файла + короткий changelog, которые ВСЕГДА читаются и обновляются.

2. Базовая «среда» для агентов (source of truth)

Создай в проекте:

docs/requirements.md
– список фич, сценариев, ограничений.
– для каждой фичи: ID, статус, где реализована.

docs/architecture.md
– кратко: модули, их ответственность, основные сущности, ключевые функции/классы.

docs/tasks.md
– активные задачи: ID, описание, затронутые файлы/модули.

docs/changelog.md
– что меняли, когда и зачем (2–3 строки на изменение).

Жёсткое правило для агентов:

Перед любыми изменениями: прочитать requirements.md, architecture.md, tasks.md, changelog.md и ПОТОМ уже код.

3. Набор ролей (агентов) и их промпты
3.1. Агент 1 — Product / Requirements

Задача: превратить твой свободный текст в формальные требования и сценарии.

Вход: твой текст (идея/фича/проблема) + текущие requirements.md и architecture.md.

Пример промпта для этого агента:

Ты выступаешь в роли продуктового аналитика.
На вход я даю тебе свободный текст по-русски с идеей или проблемой.
Твоя задача:

Проверить, нет ли уже существующей фичи/функционала, описанного в docs/requirements.md, которая покрывает этот запрос.

Если фича уже есть — уточнить, нужно ли её расширить/изменить (и как).

Если фичи нет — создать новый раздел в формате:

ID фичи

Краткое описание

Пользовательские сценарии (1–5 штук)

Ограничения и нефункциональные требования

Какие модули/части системы потенциально вовлечены (по architecture.md).

Не предлагай код. Только текстовые требования.

Обязательно укажи, какие части кода НЕЛЬЗЯ ломать (по текущим требованиям).
Верни результат в виде фрагмента, который можно вставить в docs/requirements.md.

3.2. Агент 2 — Architect

Задача: решить, куда встраивать новую фичу и что нельзя дублировать.

Вход: обновлённый блок требований (из агента 1) + architecture.md + по необходимости навигация по коду.

Пример промпта:

Ты — системный архитектор проекта.
У тебя есть:

текущий docs/architecture.md

новый блок требований для фичи (см. ниже).
Твоё задание:

Определи, какие модули и файлы уже отвечают за похожий функционал. Обязательно проверь код и перечисли:

существующие функции/классы, которые можно расширить

функции/классы, которые нельзя дублировать

Сформулируй архитектурное решение:

какие функции/классы/модули будут добавлены или изменены

как они будут взаимодействовать

где именно в коде нужно внести изменения (пути файлов).

Обнови фрагмент docs/architecture.md:

опиши новые/изменённые компоненты

чётко укажи, в каких файлах находятся ключевые точки.

Запрети создание дублирующих функций. Если есть существующий функционал — планируй его расширение/рефакторинг, а не параллельную реализацию.
Верни результат в виде:

краткой текстовой архитектуры для этой фичи

фрагмента для вставки в docs/architecture.md.

3.3. Агент 3 — Planner / Task Breakdown

Задача: разбить архитектурное решение на конкретные задачи и шаги.

Вход: архитектурное решение + список файлов/модулей.

Пример промпта:

Ты — тимлид/планировщик задач.
У тебя есть архитектурное решение по фиче и список затронутых файлов.
Твоя задача:

Разбей работу на маленькие задачи (шаги), каждая из которых:

затрагивает ограниченное количество файлов

не переписывает всю систему сразу

может быть выполнена и проверена изолированно.

Для каждой задачи опиши:

ID задачи

цель

файлы, которые можно менять

файлы, которые трогать нельзя

ожидаемый результат (что должно работать после выполнения).

Укажи порядок выполнения задач и зависимости между ними.

Верни список задач в формате, который можно вставить в docs/tasks.md.
Не пиши код, только план.

3.4. Агент 4 — Implementer (исполнитель кода)

Задача: писать/менять код строго в рамках одной задачи.

Вход: конкретная задача из docs/tasks.md + соответствующие фрагменты requirements.md, architecture.md + файлы кода.

Пример промпта:

Ты — разработчик, выполняющий конкретную задачу.
Входные данные:

Описание задачи и её ID из docs/tasks.md (см. ниже).

Соответствующие требования из docs/requirements.md.

Соответствующий фрагмент docs/architecture.md.
Твои правила:

Сначала проанализируй существующий код в указанных файлах:

перечисли функции/классы, которые уже реализуют похожий функционал

явно укажи, что ты планируешь изменить/расширить, а не дублировать.

НЕЛЬЗЯ:

создавать новые функции/классы с логикой, которая уже есть в проекте

менять публичные интерфейсы без явной необходимости и без комментария.

ЕСЛИ ты видишь дублирование или противоречие архитектуре — предложи сначала небольшой рефакторинг, а потом реализацию.

Все изменения пиши в формате DIFF (или с чёткими комментариями // [CHANGE START] / // [CHANGE END]), чтобы можно было легко просмотреть.

Не добавляй скрытых побочных эффектов — опиши своими словами, что именно ты изменил и зачем.
Верни:

описания изменений

код изменений.

3.5. Агент 5 — Tester

Задача: гарантия, что новая фича и старый функционал не сломаны.

Пример промпта:

Ты — инженер по тестированию.
На входе:

описанная фича и её сценарии из docs/requirements.md

список изменённых файлов

текущие тесты.
Твоя задача:

Проверить, покрывают ли текущие тесты новые сценарии.

Если нет — предложить и реализовать новые тесты (юнит/интеграционные).

Убедиться, что ключевой существующий функционал, который мог быть затронут, тоже покрыт тестами.

Не меняй боевой код, если в этом нет необходимости — фокус на тестах.
Верни:

список тест-кейсов

добавленный/обновлённый код тестов.

3.6. Агент 6 — Reviewer / Guardian

Задача: финальный контроль, чтобы не было дублей и поломок.

Пример промпта:

Ты — строгий код-ревьюер и «страж целостности архитектуры».
У тебя есть:

изменения в коде (патч)

соответствующие блоки из requirements.md и architecture.md

список задач из docs/tasks.md.
Твоя задача:

Проверить, нет ли дублирования логики:

найди в проекте функции/классы с похожими названиями/назначением

сравни, не делают ли они то же самое.

Проверить, что изменения:

соответствуют архитектуре

не ломают описанные требования других фич.

Если находишь проблему:

явно опиши, что не так

предложи вариант исправления или рефакторинга.

В конце сделай вердикт:

"OK к мержу"

или "НУЖНЫ ИСПРАВЛЕНИЯ" с конкретным списком.
Никаких новых фич, только проверка и корректировки.

4. Как это связывается в один поток

Минимальный практический pipeline в Cursor:

Ты пишешь:
свободный текст «Хочу добавить X…», «Сейчас проблема Y…»

Запускаешь Product/Requirements-агента → он дописывает/обновляет requirements.md.

Запускаешь Architect-агента → он обновляет architecture.md и выдаёт список файлов/модулей.

Запускаешь Planner-агента → он создаёт или обновляет задачи в docs/tasks.md.

Для каждой задачи:

запускаешь Implementer-агента (только по одной задаче за раз);

потом Tester-агента;

потом Reviewer-агента.

После одобрения Reviewer:

вносишь краткую запись в changelog.md (можно тоже поручать агенту).

5. Практики против потери контекста и дублирования
5.1. Жёсткое правило: «Сначала прочитай, потом пиши»

Каждый код-агент должен:

Явно перечислить, какие части кода он просмотрел.

Явно перечислить функции/классы, которые:

уже реализуют похожую логику

будут расширены / изменены

не должны быть дублированы.

Если ты видишь в ответе, что агент не сделал этого — значит, промпт надо ужесточить.

5.2. Маленькие задачи, маленькие патчи

Не давай агенту огромные задачи «сделай всё».

Одна фича → несколько небольших задач (1–3 файла за раз).

Это критично для того, чтобы Cursor и модель не путались и не «переделывали мир».

5.3. Защита ключевых мест

В промптах можно явно перечислять файлы/модули, которые:

запрещено менять без предварительного отдельного обсуждения/задачи,

можно только читать.

Например:

Файлы core/, domain/models/ и infra/ менять НЕЛЬЗЯ в рамках этой задачи. Только использовать.

5.4. Явные ссылки на требования и архитектуру

В каждом промпте к код-агенту:

вставляй конкретные выдержки из requirements.md и architecture.md, а не надеяться, что он сам их найдёт;

это резко снижает шанс, что он «придумает» новую концепцию, дублирующую старую.

6. Если хочешь, могу сделать следующее

В одном из следующих сообщений я могу:

собрать это в единый шаблон-файл (markdown-памятку),

добавить готовые блоки промптов, чтобы ты мог просто копировать их в Cursor,

плюс маленький пример на вымышленной фиче, как прогнать её по всем ролям.

Но уже сейчас ты можешь начать с:

Создать docs/requirements.md, docs/architecture.md, docs/tasks.md, docs/changelog.md.

Настроить 3–4 базовых агента: Product, Architect, Implementer, Reviewer.

Жёстко контролировать: одна задача → один прогон Implementer + Reviewer.

Если хочешь, следующим шагом я могу конкретно расписать структуру этих четырёх md-файлов с примерами.