# Тестирование Elocal Calls Integration

## Проблема с аутентификацией

Текущая реализация аутентификации не работает полностью. Сервер возвращает 200, но остается на странице логина, что указывает на проблему с форматом данных или методом аутентификации.

## Возможные причины

1. Форма может использовать AJAX запросы вместо обычного POST
2. Могут требоваться дополнительные поля (например, commit, utf8)
3. Может быть нужен другой endpoint для POST запроса
4. Может требоваться JavaScript для выполнения аутентификации

## Текущий статус

- ✅ CSRF токен извлекается успешно
- ✅ Cookies извлекаются из ответа
- ❌ Аутентификация не проходит (сервер возвращает страницу логина)

## Тестовые endpoints

После запуска сервера доступны следующие endpoints для тестирования:

### 1. Тест аутентификации
```bash
curl -X POST http://localhost:3001/api/test/elocal/calls/auth
```

### 2. Тест загрузки CSV (без сохранения)
```bash
curl "http://localhost:3001/api/test/elocal/calls?start_date=2024-11-01&end_date=2024-11-30"
```

### 3. Полная синхронизация (аутентификация + загрузка + сохранение)
```bash
curl -X POST http://localhost:3001/api/test/elocal/calls/sync \
  -H "Content-Type: application/json" \
  -d '{"start_date": "2024-11-01", "end_date": "2024-11-30"}'
```

## Следующие шаги

1. **Исследовать реальную форму входа** - открыть страницу в браузере и посмотреть Network tab, чтобы увидеть, какие запросы отправляются при логине
2. **Попробовать использовать библиотеку для веб-скрапинга** (например, Puppeteer) для более реалистичной аутентификации
3. **Проверить, есть ли API endpoint** для аутентификации вместо веб-формы
4. **Использовать сохраненные cookies** - если есть способ получить валидные cookies вручную, можно использовать их напрямую

## Альтернативный подход

Если веб-аутентификация слишком сложна, можно:
1. Использовать Puppeteer для автоматизации браузера
2. Сохранять cookies вручную и использовать их
3. Искать альтернативный API endpoint для экспорта данных

